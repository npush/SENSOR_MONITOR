#include <Arduino.h>

#include "ADS1110.h"
#include "ADS1X15.h"

#define ADS1115_ADC

const byte DEV_ADDR = 0x48;            // DEC: 72 - I2C address of the ADC1110 (CHANGE AS NEEDED)
ADS1110 ads1110(DEV_ADDR);

const byte DEV_ADDR = 0x49;
ADS1115 ads1115(DEV_ADDR);

volatile bool readFlag = false;
volatile unsigned long timestamp = 0;
volatile int adc_code;

// Калибровочные точки:
const int16_t adc1 = -91;    // код при 0 Па
const int16_t adc2 = 100;   // код при 1.000 бар (100000 Па)

const float P1 = 0.1;         // давление при adc1
const float P2 = 1.0;    // давление при adc2

const float a = (P2 - P1) / (adc2 - adc1);
const float b = P1 - a * adc1;


// put function declarations here:
int myFunction(int, int);
uint8_t calcCRC(const String& str);
float toVoltage(int16_t adc_code, float vref = 2.048, int gain = 8);
float toPresure(int16_t adc_code);

void setup() {
  // put your setup code here, to run once:
  int result = myFunction(2, 3);

  Serial.begin(115200);
  Wire.begin();
  ads1110.reset();
  Serial.println("Raw ADC value: ");
  Serial.println();
  
  ads1110.setGain(GAIN_8);

  // Настройка Timer1 на вызов прерывания каждую 1 мс
  cli(); // Отключить прерывания
  TCCR1A = 0;
  TCCR1B = 0;
  TCNT1 = 0;
  OCR1A = 249; // Счёт до 249 для 1 мс при предделителе 64 (16MHz / 64 / 1000 = 250)
  TCCR1B |= (1 << WGM12); // CTC режим
  TCCR1B |= (1 << CS11) | (1 << CS10); // Предделитель 64
  TIMSK1 |= (1 << OCIE1A); // Разрешить прерывание по совпадению
  sei();
}

ISR(TIMER1_COMPA_vect) {
  readFlag = true;
  timestamp++;
}

void loop() {
  // put your main code here, to run repeatedly:

  if (readFlag) {
    readFlag = false;

    adc_code = ads1110.getData();
    if (ads1110.getDataStatus() == 1) {
      String line = String(timestamp) + ";" + String(adc_code) + ";" + String(toVoltage(adc_code)) + ";" + String(toPresure(adc_code));
      uint8_t crc = calcCRC(line);
      Serial.print(line);
      Serial.print(";");
      Serial.println(crc);
    }
  }
}

// put function definitions here:
int myFunction(int x, int y) {
  return x + y;
}

uint8_t calcCRC(const String& str) {
  uint8_t crc = 0;
  for (size_t i = 0; i < str.length(); ++i) {
    crc ^= str[i];
  }
  return crc;
}

float toVoltage(int16_t adc_code, float vref, int gain) {
  return (adc_code / 32768.0) * vref / gain;
}

float toPresure(int16_t adc_code) {
  return a * adc_code + b;
}
